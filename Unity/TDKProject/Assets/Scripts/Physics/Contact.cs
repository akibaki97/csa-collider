using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Model.MathAndGeometry;

namespace Model
{
    namespace PhysicsSimulation
    {
        /// <summary>
        /// A contact point generated by the collision dispatcher
        /// </summary>
        /// <remarks>
        /// This class is responsible for calculating the collision response
        /// for one contact point in the collision.
        /// </remarks>
        public class Contact
        {
            public Contact() { }
            /// <summary>
            /// Constructing the contact from the collision detector's data.
            /// </summary>
            /// <param name="triNormal"> The triangle's normal which participates
            /// int the collision from the terrain's side. </param>
            /// <param name="vec1"> The intersected segment's first endpoint. </param>
            /// <param name="vec2"> The intersected segment's second endpoint. </param>
            /// <param name="contactInWorld"> The contact point in world coordinates. </param>
            /// <param name="body"> The dynamic rigidbody which takes part in the collision. </param>
            public Contact(Vector3 triNormal, Vector3 vec1, Vector3 vec2, Vector3 contactInWorld, RigidBody body)
            {
                // the contact normal (basisX) is always presented from the first objects view
                Vector3 baseX = -triNormal;
                Vector3 baseY = Vector3.Normalize(vec2 - vec1);
                Vector3 baseZ = Vector3.Cross(triNormal, baseY);
                contactBase = new Matrix3x3(baseX, baseY, baseZ);


                restitution = body.restitution;
                penetration = Vector3.Dot(vec1 - contactInWorld, -triNormal);
                this.contactInWorld = contactInWorld;
                relativeContactPosition = contactInWorld - body.Position;

                angularInertia = Vector3.Dot(
                    Vector3.Cross(
                        body.InvInertiaTensorWorld * Vector3.Cross(relativeContactPosition, contactBase[0]),
                        relativeContactPosition
                        ),
                    contactBase[0]);
                invTotalInertia = 1 / (body.InverseMass + angularInertia);
            }

            public Contact(Triangle tri, Vector3 contactInWorld, RigidBody body)
            {
                Vector3 baseX = -tri.Normal;
                Vector3 baseY = Vector3.Normalize(tri[2] - tri[1]);
                Vector3 baseZ = Vector3.Cross(tri.Normal, baseY);
                contactBase = new Matrix3x3(baseX, baseY, baseZ);

                restitution = body.restitution;
                penetration = Vector3.Dot(tri[1] - contactInWorld, -tri.Normal);

                this.contactInWorld = contactInWorld;
                relativeContactPosition = contactInWorld - body.Position;

                angularInertia = Vector3.Dot(
                    Vector3.Cross(
                        body.InvInertiaTensorWorld * Vector3.Cross(relativeContactPosition, contactBase[0]),
                        relativeContactPosition
                        ),
                    contactBase[0]);
                invTotalInertia = 1 / (body.InverseMass + angularInertia);
            }

            /// <summary>
            /// Calculating the velocity (linear + angular) of the contact point in contact coordinates
            /// </summary>
            /// <param name="body"></param>
            /// <returns></returns>
            private Vector3 CalculateLocalVelocity(RigidBody body)
            {
                Vector3 contactVelocityW = Vector3.Cross(body.AngularVelocity, relativeContactPosition) + body.Velocity;
                Vector3 contactVelocityL = contactBase.Transposed() * contactVelocityW;
                return contactVelocityL;
            }

            /// <summary>
            /// Calculating the desired velocity after the collision.
            /// </summary>
            /// <param name="body"></param>
            /// <returns></returns>
            private float CalculateDesiredDeltaVelocity(RigidBody body)
            {
                float velocityFromAcc = Vector3.Dot(body.Acceleration * Time.fixedDeltaTime, contactBase[0]);

                if (Mathf.Abs(contactVelocity.x) < velocityLimitConst)
                {
                    restitution = 0.0f;
                }

                return -contactVelocity.x - restitution * (contactVelocity.x - velocityFromAcc);
            }

            /// <summary>
            /// Applying the position change to resolve the interpenetration.
            /// </summary>
            /// <param name="body"></param>
            /// <param name="translation"></param>
            /// <param name="rotation"></param>
            public void ApplyPositionChange(RigidBody body, out Vector3 translation, out Vector3 rotation)
            {
                //Debug.Log("penetration: " + penetration);

                // calculate the appropriate proportions of linear and angular move
                float linearMove = penetration * body.InverseMass / (body.InverseMass + angularInertia);
                float angularMove = penetration * angularInertia / (body.InverseMass + angularInertia);

                // avoiding excessive rotation
                float limit = angularLimitConst * relativeContactPosition.magnitude;
                if (Mathf.Abs(angularMove) > limit)
                {
                    float totalMove = linearMove + angularMove;
                    angularMove = Mathf.Sign(angularMove) * limit;
                    linearMove = totalMove - angularMove;
                }

                // set the rotation we have to apply
                translation = linearMove * contactBase[0];
                rotation = angularMove * (body.InvInertiaTensorWorld * (Vector3.Cross(relativeContactPosition, contactBase[0])) / angularInertia);

                // apply the position and orientation changes
                body.Translate(translation);
                body.Rotate(rotation);
            }

            /// <summary>
            /// Calculating the collisioni response impulse.
            /// </summary>
            /// <param name="body"></param>
            /// <returns></returns>
            /// <remarks>
            /// The friction force here presented with micro-collisions in the direct of the
            /// two vector spanning the plane, which is actually the second and third vector of
            /// the contact base.
            /// </remarks>
            private Vector3 CalculateImpulseWithFriction(RigidBody body)
            {
                // calculating the matrix which substitudes the cross product of vectors
                Matrix3x3 relContPosCrossMx = Matrix3x3.SkewSymmetric(relativeContactPosition);

                // this matrix will convert a unit impulse into the caused velocity in
                // contact coordinates
                Matrix3x3 deltaVelocityMx = contactBase.Transposed() * (
                    relContPosCrossMx *
                    body.InvInertiaTensorWorld *
                    relContPosCrossMx *
                    contactBase);

                deltaVelocityMx = Matrix3x3.Diag(-1,-1,-1) * deltaVelocityMx;

                deltaVelocityMx[0, 0] += body.InverseMass;
                deltaVelocityMx[1, 1] += body.InverseMass;
                deltaVelocityMx[2, 2] += body.InverseMass;

                // the inverse matrix converts a unity velocity into an impulse in
                // contact coordinates
                Matrix3x3 impulseMx = deltaVelocityMx.Inverse();

                // the velocity we want to achieve if the friction is static
                Vector3 targetVel = new Vector3(desiredDeltaVelocity, -contactVelocity.y, -contactVelocity.z);

                // converting the given velocity into an impulse
                Vector3 impulseContact = impulseMx * targetVel;

                float planarImpulseMagnitude = Mathf.Sqrt(
                    impulseContact.y * impulseContact.y +
                    impulseContact.z * impulseContact.z);
                
                // if the impulse paralell to the plane bigger than
                // the right side of the inequation, we need dynamic friction
                if (planarImpulseMagnitude > Mathf.Abs(impulseContact.x) * body.friction)
                {
                    impulseContact.y /= planarImpulseMagnitude;
                    impulseContact.z /= planarImpulseMagnitude;

                    impulseContact.y *= body.friction * Mathf.Abs(impulseContact.x);
                    impulseContact.z *= body.friction * Mathf.Abs(impulseContact.x);
                }

                return impulseContact;
            }

            public void ApplyImpulse(RigidBody body)
            {

                //Debug.Log(contactNormal.ToString());
                if (Mathf.Approximately(body.friction, 0))
                {
                    // converting the impulse back to world coordinates, then we
                    // can apply it
                    Vector3 impulse = desiredDeltaVelocity * invTotalInertia * contactBase[0];
                    body.AddImpulse(impulse, relativeContactPosition);
                }
                else
                {
                    // converting the impulse back to world coordinates, then we
                    // can apply it
                    Vector3 impulse = contactBase * CalculateImpulseWithFriction(body);
                    body.AddImpulse(impulse, relativeContactPosition);
                }
            }

            /// <summary>
            /// Calculating the internals needed for resolve interpenetration
            /// </summary>
            /// <param name="body"></param>
            public void CalculateInternals(RigidBody body)
            {
                contactVelocity = CalculateLocalVelocity(body);
                desiredDeltaVelocity = CalculateDesiredDeltaVelocity(body);
            }

            /// <summary>
            /// Updating the relative contact position if the body position changed
            /// </summary>
            /// <param name="contactInWorld"></param>
            /// <param name="body"></param>
            public void UpdateRelativeContactPosition(Vector3 contactInWorld, RigidBody body)
            {
                relativeContactPosition = contactInWorld - body.Position;
            }
            

            /// <summary>
            /// The matrix which transforms the contacts local
            /// coordinates to world coordinates
            /// </summary>
            public Matrix3x3 contactBase;

            /// <summary>
            /// Penetration along the contact normal
            /// </summary>
            public float penetration;

            /// <summary>
            /// The body's restitution
            /// </summary>
            public float restitution;

            /// <summary>
            /// The contact position relative to the rigidbody center of mass
            /// </summary>
            public Vector3 relativeContactPosition;
            
            /// <summary>
            /// The contact point's velocity in contact coordinates
            /// </summary>
            public Vector3 contactVelocity;

            /// <summary>
            /// The contact point in world coordinates
            /// </summary>
            public Vector3 contactInWorld;

            /// <summary>
            /// The contact point's velocity along the contact normal
            /// after the collision
            /// </summary>
            public float desiredDeltaVelocity;

            public float angularInertia;
            public float invTotalInertia;

            /// <summary>
            /// Maximum amount we can rotate when resolving the interpenetration
            /// </summary>
            private const float angularLimitConst = 0.1f;

            /// <summary>
            /// Under this limit, we assume the contact is a resting
            /// contact
            /// </summary>
            private const float velocityLimitConst = 0.2f;
        }
    }
}